import { SVGMakerClient, Types as SVGMakerTypes } from '@genwave/svgmaker-sdk';

let svgMaker: SVGMakerClient;

export function initializeSvgmakerService(apiKey: string, rateLimitRpmStr?: string, baseUrl?: string) {
    const rateLimit = rateLimitRpmStr ? parseInt(rateLimitRpmStr, 10) : 2;
    const config: any = {
        logging: false,
        rateLimit: rateLimit, // RPM
    };
    
    // Add baseUrl to config if provided
    if (baseUrl) {
        config.baseUrl = baseUrl;
    }
    
    svgMaker = new SVGMakerClient(apiKey, config);
}

export async function generateSVG(params: SVGMakerTypes.GenerateParams): Promise<SVGMakerTypes.GenerateResponse> {
    if (!svgMaker) throw new Error("SVGMakerService not initialized.");
    try {
        // Ensure svgText is true to get the content
        const configuredParams = { ...params, svgText: true };
        const result = await svgMaker.generate.configure(configuredParams).execute();
        return result;
    } catch (error) {
        throw error; // Re-throw to be caught by tool handler
    }
}

export async function editSVG(params: SVGMakerTypes.EditParams): Promise<SVGMakerTypes.EditResponse> {
    if (!svgMaker) throw new Error("SVGMakerService not initialized.");
    try {
        const configuredParams = { ...params, svgText: true };
        const result = await svgMaker.edit.configure(configuredParams).execute();
        return result;
    } catch (error) {
        throw error;
    }
}

export async function convertImageToSVG(params: SVGMakerTypes.ConvertParams): Promise<SVGMakerTypes.ConvertResponse> {
    if (!svgMaker) throw new Error("SVGMakerService not initialized.");
    try {
        const configuredParams = { ...params, svgText: true };
        const result = await svgMaker.convert.configure(configuredParams).execute();
        return result;
    } catch (error) {
        throw error;
    }
}


import { Server } from '@modelcontextprotocol/sdk/server/index.js';
import { 
    CallToolRequestSchema,
    ListToolsRequestSchema,
    TextContent 
} from '@modelcontextprotocol/sdk/types.js';
import { z } from 'zod';
import { zodToJsonSchema } from 'zod-to-json-schema';
import * as svgmakerService from '../services/svgmakerService.js';
import * as fileUtils from '../utils/fileUtils.js';

const GenerateToolInputSchema = z.object({
    prompt: z.string().min(1, "Prompt cannot be empty."),
    output_path: z.string().min(1, "Output path cannot be empty."),
    quality: z.enum(['low', 'medium', 'high']).optional().describe("Quality level - affects aspect ratio: low/medium use 'auto', high uses 'square'"),
    aspectRatio: z.enum(['square', 'portrait', 'landscape']).optional().describe("Aspect ratio for the generated SVG"),
});

export function registerGenerateTool(server: Server) {
    // Register the list tools handler if not already registered
    server.setRequestHandler(ListToolsRequestSchema, async () => {
        return {
            tools: [
                {
                    name: "svgmaker_generate",
                    description: "Generates an SVG image from a text prompt using SVGMaker API and saves it to a specified local path.",
                    inputSchema: zodToJsonSchema(GenerateToolInputSchema),
                }
            ]
        };
    });

    // Register the call tool handler if not already registered
    server.setRequestHandler(CallToolRequestSchema, async (request) => {
        const { name, arguments: args } = request.params;
        
        if (name !== "svgmaker_generate") {
            throw new Error(`Unknown tool: ${name}`);
        }

        try {
            const validatedArgs = GenerateToolInputSchema.parse(args);
            
            // Note: In a real implementation, we'd need to get roots from the client
            // For now, we'll use a simple path validation
            const clientRoots: any[] = []; // server.getRoots() is not available in this SDK version
            const validatedOutputPath = await fileUtils.resolveAndValidatePath(validatedArgs.output_path, clientRoots, 'write');

            // Determine aspect ratio based on quality and explicit aspectRatio
            let finalAspectRatio = validatedArgs.aspectRatio;
            if (!finalAspectRatio) {
                if (validatedArgs.quality === 'high') {
                    finalAspectRatio = 'square';
                } else {
                    finalAspectRatio = 'auto' as any; // low and medium use auto
                }
            }

            const sdkParams = {
                prompt: validatedArgs.prompt,
                quality: validatedArgs.quality,
                aspectRatio: finalAspectRatio,
                svgText: true,
            };

            const result = await svgmakerService.generateSVG(sdkParams as any);

            if (result.svgText) {
                await fileUtils.writeFile(validatedOutputPath, result.svgText);
                return {
                    content: [{ type: 'text', text: `SVG generated successfully: ${validatedOutputPath}` } as TextContent]
                };
            } else {
                throw new Error("SVGMaker API did not return SVG content.");
            }
        } catch (error: any) {
            return {
                isError: true,
                content: [{ type: 'text', text: `Error generating SVG: ${error.message}` } as TextContent]
            };
        }
    });
}


#!/usr/bin/env node

import { Server } from '@modelcontextprotocol/sdk/server/index.js';
import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';
import {
    CallToolRequestSchema,
    ListToolsRequestSchema,
} from '@modelcontextprotocol/sdk/types.js';
import dotenv from 'dotenv';
import { initializeSvgmakerService } from './services/svgmakerService.js';
import { registerGenerateTool } from './tools/generateTool.js';

// Load environment variables
dotenv.config();

async function main() {
    const apiKey = process.env.SVGMAKER_API_KEY;
    if (!apiKey) {
        process.exit(1);
    }

    // Initialize the MCP server
    const server = new Server(
        {
            name: "svgmaker-server",
            version: "0.1.0",
        },
        {
            capabilities: {
                tools: {},
            },
        }
    );

    // Initialize SVGMaker Service
    initializeSvgmakerService(apiKey, process.env.SVGMMAKER_RATE_LIMIT_RPM, process.env.SVGMMAKER_BASE_URL);

    // Set up tool handlers
    server.setRequestHandler(ListToolsRequestSchema, async () => {
        return {
            tools: [
                {
                    name: "svgmaker_generate",
                    description: "Generates an SVG image from a text prompt using SVGMaker API and saves it to a specified local path.",
                    inputSchema: {
                        type: "object",
                        properties: {
                            prompt: {
                                type: "string",
                                description: "Text prompt for SVG generation"
                            },
                            output_path: {
                                type: "string",
                                description: "Local file path where the SVG will be saved"
                            },
                            quality: {
                                type: "string",
                                enum: ["low", "medium", "high"],
                                description: "Quality level - affects aspect ratio: low/medium use 'auto', high uses 'square'"
                            },
                            aspectRatio: {
                                type: "string",
                                enum: ["square", "portrait", "landscape"],
                                description: "Aspect ratio for the generated SVG"
                            }
                        },
                        required: ["prompt", "output_path"]
                    }
                }
            ]
        };
    });

    server.setRequestHandler(CallToolRequestSchema, async (request) => {
        const { name, arguments: args } = request.params;
        
        if (name !== "svgmaker_generate") {
            throw new Error(`Unknown tool: ${name}`);
        }

        try {
            // Ensure args exists
            if (!args) {
                throw new Error("No arguments provided");
            }
            
            // Simple validation
            if (!args.prompt || typeof args.prompt !== 'string') {
                throw new Error("Prompt is required and must be a string");
            }
            if (!args.output_path || typeof args.output_path !== 'string') {
                throw new Error("Output path is required and must be a string");
            }

            // Basic path validation (simplified for now)
            const outputPath = args.output_path as string;
            if (!outputPath.endsWith('.svg')) {
                throw new Error("Output path must end with .svg extension");
            }

            // Determine aspect ratio based on quality and explicit aspectRatio
            let finalAspectRatio = args.aspectRatio as string;
            if (!finalAspectRatio) {
                if (args.quality === 'high') {
                    finalAspectRatio = 'square';
                } else {
                    finalAspectRatio = 'auto';
                }
            }

            const sdkParams = {
                prompt: args.prompt as string,
                quality: args.quality as string,
                aspectRatio: finalAspectRatio,
                svgText: true,
            };

            // Import the service function dynamically to avoid circular imports
            const { generateSVG } = await import('./services/svgmakerService.js');
            const result = await generateSVG(sdkParams as any);

            if (result.svgText) {
                // Import file utils and validate path
                const { writeFile, resolveAndValidatePath } = await import('./utils/fileUtils.js');
                const validatedPath = await resolveAndValidatePath(outputPath, [], 'write');
                await writeFile(validatedPath, result.svgText);
                
                return {
                    content: [{
                        type: 'text',
                        text: `SVG generated successfully and saved to: ${validatedPath}`
                    }]
                };
            } else {
                throw new Error("SVGMaker API did not return SVG content.");
            }
        } catch (error: any) {
            return {
                isError: true,
                content: [{ 
                    type: 'text', 
                    text: `Error generating SVG: ${error.message}` 
                }]
            };
        }
    });

    // Connect to stdio transport
    const transport = new StdioServerTransport();
    await server.connect(transport);

    // Handle graceful shutdown
    process.on('SIGINT', async () => {
        await server.close();
        process.exit(0);
    });
}

main().catch(error => {
    process.exit(1);
});